<html> 
	<head> 
		<title>My first Three.js app</title> 
		<style> body { margin: 0; } canvas { width: 100%; height: 100% } 
		</style> 
	</head> 
	<body> 
	<script src="js/three.min.js"></script> 
<!--	<script src="js/jquery-2.1.3.min.js"></script> -->
	<script> // Our Javascript will go here. 

	// n is number of values in the perceptron.
		function Perceptron(n) {
			this.weights = new Array(n);
			
			//Inputs for each of the possible values.
			this.inputs = new Array(n);
			
			// Learning constant
			this.lc = 0.5;
			//this.sum = 0;
			
			for (var i = 0; i < this.weights.length; i++) {
				var plusOrMinus = Math.random() < 0.5 ? -1 : 1;
				var weight = Math.random();
				this.weights[i] = this.weight;
			};
			

			Perceptron.prototype.feedForward = function() {
				var sum = 0;
				for (var i = 0; i < this.weights.length; i++) {
					sum +=this.inputs[i]*this.weights[i];
				};
				return activate(sum);
			};

			var activate = function(sum) {
				if (sum > 0) {return 1;}
				else {return 0;}
			};

			Perceptron.prototype.train = function(desired) {
				var guess = this.feedForward();
				var error = desired - guess;
				for (var i = 0; i < this.weights.length; i ++){
					this.weights[i] += this.lc * error * this.inputs[i];
				}
			}

		};


		function CubeTrainer(){
			var side = 50.0;
			var xPos, yPos, zPos = 0.0; // Lower left corner

			CubeTrainer.prototype.answer = function(x, y, z, a){

			inputs = new Array(3);
			inputs[0] = x;
			inputs[1] = y;
			inputs[2] = z; 
			inputs[3] = 1; // Bias
			answer = a;

			if ((x < xPos || x > side || y < yPos || y > side || z < zPos || z > side) && (a==1)) {
				//console.log("outside");
				return -1;
			} else {
				//console.log("inside");
				return 1;
			}
			}
		}


		var scene = new THREE.Scene(); 
		var camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, 0.1, 1000 ); 
		var renderer = new THREE.WebGLRenderer(); 
		renderer.setSize( window.innerWidth, window.innerHeight ); 
		document.body.appendChild( renderer.domElement ); 

/*
		var g1 = new THREE.Geometry(); 
		g1.vertices.push( new THREE.Vector3( -10, 10, 0 ), new THREE.Vector3( -10, -10, 0 ), new THREE.Vector3( 10, -10, 0 ) );
		g1.faces.push( new THREE.Face3( 0, 1, 2 ) ); 
		g1.computeBoundingSphere();
		
*/
		var geometry = new THREE.BoxGeometry( 50, 50, 50 ); 
		var material = new THREE.MeshBasicMaterial( { 
			transparent: true, 
			opacity: 0.5,
			color: 0x00ff00 } ); 

		var radius = 1, segments = 16, rings = 16;
		
		var inMaterial =
  			new THREE.MeshLambertMaterial(
    		{
      			color: 0xCC0000
    		});

        var outMaterial =
  			new THREE.MeshLambertMaterial(
    		{
      			color: 0x0f00f0
    		});

var pointLight =
  new THREE.PointLight(0xFFFFFF);

// set its position

pointLight.position.x = 10;
pointLight.position.y = 50;  
pointLight.position.z = 130;

// add to the scene
scene.add(pointLight);


		
		//a = [1,2,3];
		
		//p.activate(5);
		//p.inputs = a;
		//p.feedForward();

		var cube = new THREE.Mesh( geometry, material ); 
		cube.position.x = 0;
		cube.position.y = 0;
		cube.position.z = 0;
		scene.add( cube );
		//	scene.add( tri );
		camera.position.z = 100; 
		var render = function () { 
			requestAnimationFrame( render ); 
			//cube.rotation.x += 0.01;
			//cube.rotation.y += 0.01;
			renderer.render(scene, camera); }; 

		var p = new Perceptron(3);
		    p.weights = [0.0,0.5,0.0,0.5];
		    p.lc = 1;
			c = new CubeTrainer();
				var bxBoundary = 60;
				

	for (var i = 0; i < 1000; i++) {

				var plusOrMinus = Math.random() < 0.5 ? -1 : 1;
				var randX = Math.floor((Math.random() * bxBoundary) + 1)*plusOrMinus;
				plusOrMinus = Math.random() < 0.5 ? -1 : 1;
				var randY = Math.floor((Math.random() * bxBoundary) + 1)*plusOrMinus;
				var randZ = Math.floor((Math.random() * bxBoundary) + 1) * plusOrMinus;

				
				p.inputs = [randX, randY, randZ, 1];

			//	console.log("x= " + randX + " y= " + randY + " z=" + randZ + " guess " + p.feedForward());
			//	c.answer(randX,randY,randZ,1);


				if (p.feedForward()==0){
				sphereMaterial = inMaterial;	
				} else {
					sphereMaterial = outMaterial;
				}
				p.train(c.answer(randX,randY,randZ,1));

				var sphere = new THREE.Mesh(
		  			new THREE.SphereGeometry(
    					radius,
    					segments,
    					rings),
						sphereMaterial);

			    sphere.position.x =  randX;
				sphere.position.y =  randY;
				sphere.position.z =  randZ;
				scene.add(sphere);


   	};

   	render();
   	console.log(p.weights[0] + " " + p.weights[1] + " " + p.weights[2] + " " + p.weights[3]);
	</script> 
	<div >
		<p id="out">out</p>
	</div>
	</body> 
</html>